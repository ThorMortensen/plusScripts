#!/bin/bash

# . plusScriptsPaths
# $PS_DIR/+extract

PS_DIR_PLUS="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
PS_DIR=${PS_DIR_PLUS%/*}
PS_DIR_CONFIG=$PS_DIR/config
PS_DIR_INSTALL=$PS_DIR/install
PS_DIR_WORKERS=$PS_DIR/workers
PS_DIR_RELEASES=$PS_DIR/releases
PS_DIR_BUILD_RES=$PS_DIR/build-recepies
PS_DIR_PERSIST="$HOME/.plus-script-persist"
PS_DIR_PERSIST_DEFAULT="$PS_DIR/persist-defaults"
# GITROOT="$(git rev-parse --show-toplevel)"

print_title() {
  dye bold cyan "$1"
}


print_link() {
    echo -e "\033[1;4;34m$1\033[0m"
}


start_time=$(date +%s)

spinner_running=false
spinner_pid=0

start_spinner() {
    local message=$1
    spinner=("⠋" "⠙" "⠹" "⠸" "⠼" "⠴" "⠦" "⠧" "⠇" "⠏")

    YELLOW='\033[1;33m'
    NC='\033[0m' # No Color

    # Start the spinner in the background
    (
      while :; do
        for i in "${spinner[@]}"; do
          printf "\r${message} ${YELLOW}${i}${NC} "
          sleep 0.1
        done
      done
    ) &
    # Save the PID of the spinner
    spinner_pid=$!
    spinner_running=true
}


stop_spinner() {
    if [ "$spinner_running" = false ]; then
        return
    fi
    # Kill the spinner
    kill $spinner_pid
    spinner_running=false
    # Clear the line
    printf "\r\033[K"
}

use_braek_signal=false
break_flag=false

# Define a function to handle the SIGINT signal
handle_sigint() {
    stop_spinner
    if [ "$use_braek_signal" = false ]; then
        exit 1
    else 
        use_braek_signal=false
        break_flag=true
    fi
}
trap handle_sigint SIGINT
# Declare the mapping of IDs to names
declare -A ids_to_names
ids_to_names=(
    ["port2"]="logi02"
    ["port4"]="logi04"
)
GLOBAL_RELEASE_SELECTED="global-release-selected"
GLOBAL_PORT_SELECTED="global-port-selected"
GLOBAL_SERVICE_SELECTED="global-service-selected"
REMOTE_SERVICE_CASH="$PS_DIR_PERSIST_DEFAULT/remote-service-list"
GLOBAL_FEATURE_FLAG_SELECTED="global-feature-flag-selected"
FEATURE_FLAGS="$PS_DIR_PERSIST_DEFAULT/feature-flags"

persist_name=$(basename "$0")

SELECTED_DEVICE=""

select_port() {
  device=$(plus-menu --items "port2 port4 192.168.7.1" --persist-path "$GLOBAL_PORT_SELECTED" --prompt-msg "Select device") 
  echo "$device"
  SELECTED_DEVICE=$device
}

SELECTED_DEVICE_VARIANT=""

notify() {
    notify-send -u "critical"  "Notification" "$1"
}

select_device_variant() {
  local device_variants="iwg26-v1 iwg26-v1-can-resistor iwg26-v2 iwg26-v2-vag iwg26-v3 iwg26-v3-ag iwg26-v3-ag-vag iwg26-v3-ag-vag-nostop iwg26-v3-ag-dual-bt iwg26-v3-ag-dual iwg26-v3-ag-triple iwg26-v3-ag-full"
  SELECTED_DEVICE_VARIANT=$(plus-menu --items "$device_variants" --persist-path "$persist_name-device-variant" --prompt-msg "Select device variant")
}

JWT_TOKEN_PATH="/tmp/jwt-token"


dye() {
  local text=""
  local codes=()

  color_code() {
    case $1 in
      black) echo 0 ;;
      red) echo 1 ;;
      green) echo 2 ;;
      yellow) echo 3 ;;
      blue) echo 4 ;;
      magenta) echo 5 ;;
      cyan) echo 6 ;;
      white) echo 7 ;;
      bright-black) echo 8 ;;
      bright-red) echo 9 ;;
      bright-green) echo 10 ;;
      bright-yellow) echo 11 ;;
      bright-blue) echo 12 ;;
      bright-magenta) echo 13 ;;
      bright-cyan) echo 14 ;;
      bright-white) echo 15 ;;
      *) return 1 ;;
    esac
  }

  for arg in "$@"; do
    case $arg in
      bold|italic|blink|underline)
        case $arg in
          bold) codes+=(1) ;;
          italic) codes+=(3) ;;
          blink) codes+=(5) ;;
          underline) codes+=(4) ;;
        esac
        ;;
      fg=*|bg=*)
        local type=${arg%%=*}
        local value=${arg#*=}
        if [[ $value =~ ^[0-9]+$ ]] && (( value >= 0 && value <= 255 )); then
          if [ "$type" = "fg" ]; then
            codes+=("38;5;$value")
          else
            codes+=("48;5;$value")
          fi
        fi
        ;;
      black|red|green|yellow|blue|magenta|cyan|white|bright-black|bright-red|bright-green|bright-yellow|bright-blue|bright-magenta|bright-cyan|bright-white)
        local resolved
        resolved=$(color_code "$arg") && codes+=("38;5;$resolved")
        ;;
      bg-black|bg-red|bg-green|bg-yellow|bg-blue|bg-magenta|bg-cyan|bg-white|bg-bright-black|bg-bright-red|bg-bright-green|bg-bright-yellow|bg-bright-blue|bg-bright-magenta|bg-bright-cyan|bg-bright-white)
        local name=${arg#bg-}
        local resolved
        resolved=$(color_code "$name") && codes+=("48;5;$resolved")
        ;;
      *)
        if [ -z "$text" ]; then
          text="$arg"
        else
          text+=" $arg"
        fi
        ;;
    esac
  done

  if [ "${#codes[@]}" -eq 0 ]; then
    codes=(0)
  fi

  printf '\e[%sm%s\e[0m\n' "$(IFS=';'; echo "${codes[*]}")" "$text"
}



prompt_default_yes() {
    read -p "$1 [Y/n]: " -r
    if [[ $REPLY =~ ^[Nn]$ ]]
    then
      echo "Aborted by user."
      exit 1
    fi
}

prompt_default_no() {
    read -p "$1 [y/N]: " -r
    if [[ ! $REPLY =~ ^[Yy]$ ]]
    then
      echo "Aborted by user."
      exit 1
    fi
}

prompt() {
    read -p "$1" -r
}

get_as_items() {
    local item_path=$1
    local items

    # Read the content of the file and replace newlines with spaces
    items=$(tr '\n' ' ' < "$item_path")

    # Remove any leading or trailing whitespace
    items=$(echo "$items" | xargs)

    echo "$items"
}
